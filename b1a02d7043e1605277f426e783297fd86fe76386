{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "de1c91a1_1fc246b4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 839
      },
      "writtenOn": "2021-12-16T02:01:30Z",
      "side": 1,
      "message": "I\u0027m generally in favour of using the view\u0027s info about annotations where we can, since it\u0027s more granular.",
      "revId": "b1a02d7043e1605277f426e783297fd86fe76386",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1755ffa_56c801d6",
        "filename": "src/ce/ve.ce.Surface.js",
        "patchSetId": 1
      },
      "lineNbr": 86,
      "author": {
        "id": 839
      },
      "writtenOn": "2021-12-16T02:01:30Z",
      "side": 1,
      "message": "Should we merge this with this.activeAnnotations ?",
      "revId": "b1a02d7043e1605277f426e783297fd86fe76386",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e312f69_080a4e68",
        "filename": "src/ce/ve.ce.Surface.js",
        "patchSetId": 1
      },
      "lineNbr": 86,
      "author": {
        "id": 658
      },
      "writtenOn": "2021-12-16T13:27:30Z",
      "side": 1,
      "message": "Merge how? activeAnnotations needs to only contain ve.ce.ActiveAnnotations (links) whereas these needs to contain all annotations.",
      "parentUuid": "e1755ffa_56c801d6",
      "revId": "b1a02d7043e1605277f426e783297fd86fe76386",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f16567e_96b785e5",
        "filename": "src/ce/ve.ce.Surface.js",
        "patchSetId": 1
      },
      "lineNbr": 86,
      "author": {
        "id": 839
      },
      "writtenOn": "2021-12-16T17:10:37Z",
      "side": 1,
      "message": "I think we shouldn\u0027t extend annotations at boundaries that are soft (\u003daren\u0027t ve.ce.NailedAnnotations), because it\u0027s more or less arbitrary whether the browser puts the cursor inside or outside. (On Chromium it biases towards the earlier option in document order; in Firefox it depends how you landed there).\n\nFor non-nailed annotations, we should only extend them if we\u0027re in the interior, or if it\u0027s a non-collapsed selection (both of which we can tell from the model).",
      "parentUuid": "2e312f69_080a4e68",
      "revId": "b1a02d7043e1605277f426e783297fd86fe76386",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b4e1989_5f206cf1",
        "filename": "src/ce/ve.ce.Surface.js",
        "patchSetId": 1
      },
      "lineNbr": 86,
      "author": {
        "id": 658
      },
      "writtenOn": "2021-12-16T18:18:21Z",
      "side": 1,
      "message": "1. We need this logic to ensure the annotations are still applied at non-boundary positions, otherwise we need some more complex logic later on to work out if we are actually at a boundary.\n2. This decides if annotations will be continued by looking at where the native cursor is (inside or outside the annotation boundary), which matches up with what typing would do (tested in Chrome \u0026 FF). I think paste matching what typing does is an sensible approach.",
      "parentUuid": "6f16567e_96b785e5",
      "revId": "b1a02d7043e1605277f426e783297fd86fe76386",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84013aa7_055d9658",
        "filename": "src/ce/ve.ce.Surface.js",
        "patchSetId": 1
      },
      "lineNbr": 86,
      "author": {
        "id": 839
      },
      "writtenOn": "2021-12-17T04:12:41Z",
      "side": 1,
      "message": "1. The model logic isn\u0027t too complex. Essentially:\n\n  nonBoundaryAnnotations \u003d doc.data.getAnnotationsFromRange( new ve.Range( offset - 1, offset ) )\n\nexcept it\u0027s the empty set if you\u0027re at the start or end of the ContentBranchNode.\n\n2. Considering likely times when you\u0027d paste, I think it\u0027s most probable that you *don\u0027t* want boundary annotations to be applied â€”except if you explicitly put the selection inside the link cartouche. Other than links, the most heuristically likely annotation boundaries are bold/italic, which you probably don\u0027t want to apply on paste, but which the code will tend[*] to do at an end boundary and sometimes at a start boundary, if we rely on native browser cursor positioning.\n\n[*] Chromium\u0027s native behaviour is to place the cursor nearer the start of the document, meaning typing at an end-annotation boundary continues the annotation, but typing before an annotation does not. There are exceptions to this, e.g. if the annotation is at the start of the block node or straight after a non-editable island, then the cursor lies inside the annotation. In Firefox, it depends how you landed at the offset: if cursoring, it biases to landing in the closest offset (in document order) to where you cursored from; if clicking, it\u0027s complex but it tends to land where you visually clicked (which matters if, say, there\u0027s a text wrapping boundary or a bidi boundary or any CSS width to the annotation).",
      "parentUuid": "2b4e1989_5f206cf1",
      "revId": "b1a02d7043e1605277f426e783297fd86fe76386",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47a26dfa_50ea6d04",
        "filename": "src/ce/ve.ce.Surface.js",
        "patchSetId": 1
      },
      "lineNbr": 86,
      "author": {
        "id": 658
      },
      "writtenOn": "2021-12-17T14:39:08Z",
      "side": 1,
      "message": "1. Yes - that\u0027s what we do at the moment, but then we\u0027d end up with a mix of annotations from the model and annotations from the view and there would be a non trivial combination of the two. In this approach we simply always take annotations from the view, like would happen with cursoring.\n\n2. Yes it is less predictable in the way that typing is, but it is at least more predictable in that it is the same as typing. For me it is a six-of-one situation, but this approach results in easier to understand logic in the code: annotations are always decided the same way as typing when pasting.",
      "parentUuid": "84013aa7_055d9658",
      "revId": "b1a02d7043e1605277f426e783297fd86fe76386",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951"
    }
  ]
}