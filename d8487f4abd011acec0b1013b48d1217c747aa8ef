{
  "comments": [
    {
      "key": {
        "uuid": "6e936f18_accc46c1",
        "filename": "src/ce/ve.ce.RangeState.js",
        "patchSetId": 14
      },
      "lineNbr": 49,
      "author": {
        "id": 5
      },
      "writtenOn": "2014-11-07T19:30:38Z",
      "side": 1,
      "message": "Is this guaranteed to be a ContentBranchNode?",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e936f18_82148e52",
        "filename": "src/ce/ve.ce.RangeState.js",
        "patchSetId": 14
      },
      "lineNbr": 49,
      "author": {
        "id": 839
      },
      "writtenOn": "2014-11-13T17:48:47Z",
      "side": 1,
      "message": "Urghhh ...\n\nDuring the processing of an Enter keydown, ve.ce.BranchNode onSplice leaves a collapsed DOM selection just after the previously-active paragraph node (i.e. with anchorNode set to the div.ve-ce-documentNode and the anchorOffset set to, say, 1).\n\nUltimately the DOM selection gets restored to something more meaningful. But before this happens, the ve.dm.Document emits a transact event that causes a call to ve.ce.SurfaceObserver pollOnceNoEmit. So we end up with a spurious RangeState with a selection anchored at ve.ce.DocumentNode.\n\nThat is, it\u0027s an emit-halfway-through-changing-state quirk. It\u0027s ugly but it seems not to matter much.",
      "parentUuid": "6e936f18_accc46c1",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e936f18_657aacb9",
        "filename": "src/ce/ve.ce.RangeState.js",
        "patchSetId": 14
      },
      "lineNbr": 49,
      "author": {
        "id": 5
      },
      "writtenOn": "2014-11-13T20:04:31Z",
      "side": 1,
      "message": "OK. At a higher level, it seems sensible that the DOM selection could sometimes be in a non-content branch node, and ce.Surface would then have to correct that, but in order to do so it first needs ce.SurfaceObserver to tell it about this situation. So SurfaceObserver should be capable of notifying the Surface about non-CBN selections.",
      "parentUuid": "6e936f18_82148e52",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e936f18_4c4ca243",
        "filename": "src/ce/ve.ce.RangeState.js",
        "patchSetId": 14
      },
      "lineNbr": 101,
      "author": {
        "id": 5
      },
      "writtenOn": "2014-11-07T19:30:38Z",
      "side": 1,
      "message": "Didn\u0027t we find that this caused bugs before? Because a transaction could happen that changes the veRange associated with a selection without actually changing the selection itself. (The kind of false negative mentioned in the compareSelection documentation.)",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e936f18_6cd4fe17",
        "filename": "src/ce/ve.ce.RangeState.js",
        "patchSetId": 14
      },
      "lineNbr": 123,
      "author": {
        "id": 5
      },
      "writtenOn": "2014-11-07T19:30:38Z",
      "side": 1,
      "message": "These two lines duplicate lines 151 and 152",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e936f18_bf69a5f7",
        "filename": "src/ce/ve.ce.RangeState.js",
        "patchSetId": 14
      },
      "lineNbr": 123,
      "author": {
        "id": 839
      },
      "writtenOn": "2014-11-13T17:48:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6e936f18_6cd4fe17",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e936f18_2c783625",
        "filename": "src/ce/ve.ce.RangeState.js",
        "patchSetId": 14
      },
      "lineNbr": 173,
      "author": {
        "id": 5
      },
      "writtenOn": "2014-11-07T19:30:38Z",
      "side": 1,
      "message": "Hmm, does this behave correctly when moving from one block slug to another? It\u0027s possible that it does, it\u0027s just not immediately obvious to me why.",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e936f18_0245de46",
        "filename": "src/ce/ve.ce.RangeState.js",
        "patchSetId": 14
      },
      "lineNbr": 173,
      "author": {
        "id": 839
      },
      "writtenOn": "2014-11-13T17:48:47Z",
      "side": 1,
      "message": "It\u0027s definitely suboptimal. It relies on explicit pollOnceInternal calls synchronizing everything before the branch node changes. However, that\u0027s the same as the prior behaviour: contentChange was not emitted if there was a node change.\n\nThis is not usually a problem because blocks cannot easily be out of sync at the time that you move blocks, but (say) an un-event-ful spellcheck change would be missed if it were followed swiftly by a selection change.\n\nThis isn\u0027t trivial to fix but I think it\u0027s outside the scope of this patchset.",
      "parentUuid": "6e936f18_2c783625",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e936f18_65ab8c1a",
        "filename": "src/ce/ve.ce.RangeState.js",
        "patchSetId": 14
      },
      "lineNbr": 173,
      "author": {
        "id": 5
      },
      "writtenOn": "2014-11-13T20:04:31Z",
      "side": 1,
      "message": "I\u0027m OK with not changing the existing behavior of contentChange not being emitted when moving to a different node. What I was asking specifically was for you to convince me that something sane will happen when moving from one block slug to another. But I think that\u0027s fine now because of slug staging, and so such a move will always be from a (staged) paragraph to a slug?",
      "parentUuid": "6e936f18_0245de46",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e936f18_ccfd126b",
        "filename": "src/ce/ve.ce.SurfaceObserver.js",
        "patchSetId": 14
      },
      "lineNbr": 80,
      "author": {
        "id": 5
      },
      "writtenOn": "2014-11-07T19:30:38Z",
      "side": 1,
      "message": "What about clearing the other properties (node, text, hash) that were being cleared before? Is that not necessary?",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e936f18_2cecb6b7",
        "filename": "src/ce/ve.ce.SurfaceObserver.js",
        "patchSetId": 14
      },
      "lineNbr": 262,
      "author": {
        "id": 5
      },
      "writtenOn": "2014-11-07T19:30:38Z",
      "side": 1,
      "message": "\u0026\u0026 emitChanges",
      "revId": "d8487f4abd011acec0b1013b48d1217c747aa8ef",
      "serverId": "e9e9afe9-4712-486d-8885-f54b72dd1951",
      "unresolved": false
    }
  ]
}